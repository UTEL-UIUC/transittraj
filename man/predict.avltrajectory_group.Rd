% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/trajectory_methods.R
\name{predict.avltrajectory_group}
\alias{predict.avltrajectory_group}
\alias{predict.avltrajectory_single}
\title{Interpolate time or distance points using AVL trajectories.}
\usage{
\method{predict}{avltrajectory_group}(
  object,
  new_times = NULL,
  new_distances = NULL,
  deriv = 0,
  trips = NULL,
  ...
)

\method{predict}{avltrajectory_single}(object, new_times = NULL, new_distances = NULL, deriv = 0, ...)
}
\arguments{
\item{object}{The single or grouped trajectory object.}

\item{new_times}{Optional. A vector of numeric timepoints, or a dataframe
with at least the column \code{"event_timestamp"} of new timepoints to interpolate
at. Default is \code{NULL}.}

\item{new_distances}{Optional. A vector of numeric distances, or a dataframe
with at least the column \code{"distance"} of new distances to interpolate at.
Default is \code{NULL}.}

\item{deriv}{Optional. The derivative with which to calculate at. Default is
0.}

\item{trips}{Optional. A vector of \code{trip_id_performed}s to interpolate for.
Default is \code{NULL}, which will use all trips found in the trajectory object.}

\item{...}{Other parameters (not used).}
}
\value{
The input dataframe, with an additional column \code{"interp"} of the
interpolated values requested, and an additional \code{"trip_id_performed"}
column will all trips for which that point is within range.
}
\description{
Using a function stored in a grouped or single trajectory object, new points
will be interpolated along a trajectory. Depending on whether new_times or
new_distances is provided, the function will utilize the direct or inverse
trajectory function.
}
\details{
This function is the recommended way to use a fit trajectory function. It has
a few key features:
\subsection{Interpolate for Distance or Time}{

If \code{new_times} is provided, the function will find the \code{distance} of each
trip at each new time using the direct trajectory function. Conversely, if
\code{new_distances} is provided, the function will find the \code{event_timestamp} at
which each trip crossed that distance using the inverse trajectory function.
If an input trajectory object does not contain an inverse function, an error
will be thrown.

These new points can be either vectors or dataframes:
\itemize{
\item If the input is a vector, the returned value will be a dataframe
associating each trip with each new point and a column \code{interp} indicating
the interpolated value.
\item If the input is a dataframe, it must contain a column names
\code{event_timestamp} or \code{distance}, depending on whether it is put into
\code{new_times} or \code{new_distances}. All other columns will be preserved in the
output. Each row will be duplicated for each trip, and a column \code{interp} will
be added indicating the interpolated value.
}

The latter option is particularly useful for finding crossing times of
particular features, or the positions at notable points in time. For
instance, \code{new_distance} may be a dataframe of corridors, with a column
\code{name} for the corridor name and \code{inout} for whether each row is the
entrance or exit to the corridor. The returned value will append the column
\code{trip_id_performed} for each trip that crosses those distances, and \code{interp}
for the time the trip passes the entrance or exit.
}

\subsection{Finding Derivatives}{

Depending on the \code{interp_method} used when fitting the trajectory object, a
its derivative may be able to be found:
\itemize{
\item \code{interp_method = "linear"}. This will not allow derivatives. This is
because, at each observation, the piecewise linear function is not
differentiable.
\item \code{interp_method} is a spline from \code{stats::splinefun()}. This will typically
be differentiable up to the third degree.
}

The derivative returned (as column \code{interp}) is the derivative of distance
with respect to time. This means the first derivative is velocity, second is
acceleration, and third is jerk. The derivative is taken from the direct
trajectory, not the inverse, and the inverse trajectory cannot be used to
find derivatives. This means that if \code{new_distances} is provided, \code{deriv }
must equal 0. If starting from distance values, but derivatives are desired,
consider interpolating for timepoints first, then using these as \code{new_times}
to find the derivative.
}

\subsection{Prevents Extrapolation}{

By default, many fit interpolating curves will allow extrapolation (i.e.,
the input of an \code{event_timestamp} beyond the original time domain of the
trip). This is especially true for splines fit using \code{stats::splinefun()}.
In general, this will not be reasonable for transit vehicles: time points
should be constrained by the time that a trip has actually been observed,
and distances should be constrained to the part of a route a trip actually
ran.

This function uses the maximum and minimum time and distance values stored
in the trajectory object to identify if an input \code{new_times} or
\code{new_distances} is beyond the domain/range of each trip individually. The
returned output will only include \code{interp} values for trips within the
domain/range of the input.
}

\subsection{Accessing the Raw Trajectory Function}{

Because of the above features and protections, it is recommend that these
\code{predict()} functions are used to access the fit trajectory and inverse
trajectory functions. However, if the raw function itself is desired,
it can be accessed using \code{attr(trajectory, "traj_fun")} or
\code{attr(trajectory, "inv_traj_fun")}. For a group trajectory object, these
will return lists of individual trip functions indexed by
\code{trip_id_performed}; for single trajectory objects, these will return the
single function for that trip.
}
}
