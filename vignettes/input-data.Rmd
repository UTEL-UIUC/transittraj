---
title: "Understanding Data Inputs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{input-data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette introduces you to the input data used by `transittraj`. For most
projects, there are two important data sources:

- *Automatic vehicle location (AVL) data*: A set of GPS latitude-longitude
points describing a transit vehicle's location over time. This package requires
that AVL data follow the [TIDES](https://tides-transit.org/main/)
`vehicle-location` table schema.

- *GTFS feed*: The routes, trips, and schedules a transit
vehicle follows. The most important part is the `shapes` file, which tells us
the route alignment we expect our AVL data to follow.

We will introduce and discuss these data sources using the two public datasets
included with `transittraj`: An archive of WMATA's GTFS-rt feed, `wmata_avl`,
and an archive of WMATA's static GTFS feed, `wmata_gtfs`.

Before we begin, let's add some needed packages:

```{r setup}
library(transittraj)
library(tidytransit)
```

# Exploring Input Data

## Automatic Vehicle Location Data

`transittraj` is designed to clean and process AVL data. Unfortunately, AVL data
does not have a widely-adopted standardized format; each vendor and data
analytics platform outputs a different format, and GTFS-rt often lacks the
in-depth operational data we need to perform meaningful analyses.

In the interest of standardizing inputs to the package's functions,
`transittraj` is designed to take in files adhering to the TIDES
`vehicle-location` standard table schema. TIDES is an open standard intended
to fill the gaps described above, but is not yet widely adopted by agencies
or data providers. We recommend reformatting your AVL data to meet the TIDES
`vehicle-location` table schema, described
[here](https://tides-transit.org/main/tables/#vehicle-locations).

Let's see what TIDES AVL data looks like. The `wmata_avl` dataset provided
with `transittraj` is reformatted from GTFS-rt to meet TIDES's needs. Below
is a peak:

```{r}
head(wmata_avl)
```

To check whether an input dataframe meets our needs, we can run
`validatde_tides()`. This will check whether the needed fields are present,
and whether they have the correct data type.

```{r}
wmata_tides_val <- validate_tides(avl_df = wmata_avl)
wmata_tides_val
```

This dataset does not meet two requirements: first, it is missing an
`operator_id` column. This is okay; `operator_id` is not required by any
`transittraj` functions, though there are some that benefit from it. Second, 
the dataset is missing `distance`. This is something we'll calculate in the
cleaning process.

Read more about `transittraj`'s data requirements using `help(validate_tides)`.
Before running, each `transittraj` function will check that your input dataframe
has the fields and data types that that function requires.

## GTFS Feed

A GTFS feed gives us information we need to effectively use our AVL data.
`transittraj` is designed to use `tidygtfs` objects from the `tidytransit`
package. Let's look at the GTFS object `wmata_gtfs`, which complements the
`wmata_avl` dataset we saw above:

```{r}
summary(wmata_gtfs)
```

We recommend checking out
[`tidytransit`](https://r-transit.github.io/tidytransit/) for functions to read,
write, and manipulate GTFS feeds. `transittraj` offers a handful of additional
helper functions for working with GTFS, most notably `filter_by_route()` and
`get_shape_geometr()`. Additionally, we can also create an interactive
visualization of a GTFS feed:

``` {r, out.width = "100%", fig.align = "center"}
plot_interactive_gtfs(gtfs = wmata_gtfs,
                      color_palette = "gtfs")
```

Try clicking on routes or stops to see a pop-up with more information. This
interactive map is very useful for deciding which `shape_id` and
`direction_id` you want to work with.

# Conclusion

We now what data sources `transittraj` requires. Each function in the package
will check whether the input data meets that function's requirements, and if
it does not, an error will be thrown describing what's wrong. When in doubt,
try using `validate_tides()` or `tidytransit::validate_gtfs()` to check your
data.

In the next vignette (`vignette("data-workflow")`), we'll explore the AVL
cleaning process.
